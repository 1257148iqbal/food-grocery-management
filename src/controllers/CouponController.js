const {
    errorHandler,
    errorResponse,
    successResponse,
} = require('../helpers/apiResponse');
const {
    pagination,
    paginationMultipleModel,
} = require('../helpers/pagination');
const CouponModel = require('../models/CouponModel');
const OrderModel = require('../models/OrderModel');
const UserModel = require('../models/UserModel');
const { generateReferralCode } = require('./OrderController');
const ShopModel = require('../models/ShopModel');
const ReferralSettingModel = require('../models/ReferralSettingModel');
const { pushNotificationForCoupon } = require('./NotificationController');
const AppSetting = require('../models/AppSetting');
const moment = require('moment');
const { getCouponHistory } = require('../helpers/getCouponHistory');
const { checkCouponValidity } = require('../helpers/checkCouponValidity');

exports.getAllCoupons = async (req, res) => {
    try {
        const {
            couponType,
            couponStatus,
            searchKey,
            page = 1,
            pageSize = 50,
            pagingRange = 50,
            sortBy = 'desc',
            startDate,
            endDate,
        } = req.query;

        let config = { deletedAt: null };

        if (searchKey) {
            const newQuery = searchKey.split(/[ ,]+/);
            const nameSearchQuery = newQuery.map(str => ({
                couponName: RegExp(str, 'i'),
            }));

            config = {
                ...config,
                $and: [
                    {
                        $or: [{ $and: nameSearchQuery }],
                    },
                ],
            };
        }

        if (startDate) {
            const startDateTime = moment(new Date(startDate))
                .startOf('day')
                .toDate();
            const endDateTime = moment(endDate ? new Date(endDate) : new Date())
                .endOf('day')
                .toDate();

            config = {
                ...config,
                createdAt: {
                    $gte: startDateTime,
                    $lte: endDateTime,
                },
            };
        }

        if (
            couponType &&
            [
                'global',
                'individual_user',
                'individual_store',
                'custom_coupon',
            ].includes(couponType)
        ) {
            config = {
                ...config,
                couponType,
            };
        }

        if (couponStatus && ['active', 'inactive'].includes(couponStatus)) {
            config = {
                ...config,
                couponStatus,
            };
        }

        var paginate = await pagination({
            page,
            pageSize,
            model: CouponModel,
            condition: config,
            pagingRange,
        });

        const list = await CouponModel.find(config)
            .sort({ createdAt: sortBy })
            .skip(paginate.offset)
            .limit(paginate.limit)
            .populate('couponUsers couponShops couponInfluencer');

        for (const coupon of list) {
            await checkCouponValidity(coupon);
        }

        let isNewUserCouponExist = false;
        if (couponType === 'global') {
            const newUserCoupon = await CouponModel.findOne({
                couponType: 'global',
                onlyForNewUser: true,
                deletedAt: null,
            }).sort({ createdAt: -1 });

            if (newUserCoupon) {
                await checkCouponValidity(newUserCoupon);

                if (newUserCoupon._doc.isCouponValid) {
                    isNewUserCouponExist = true;
                }
            }
        }

        successResponse(res, {
            message: 'Successfully Find',
            data: {
                isNewUserCouponExist,
                coupons: list,
                paginate,
            },
        });
    } catch (error) {
        errorResponse(res, error.message);
    }
};

exports.getCouponById = async (req, res) => {
    try {
        const { couponId } = req.query;

        const coupon = await CouponModel.findOne({
            _id: couponId,
            deletedAt: null,
        }).populate('couponUsers couponShops couponInfluencer');

        if (!coupon) {
            return errorResponse(res, 'Coupon not found');
        }

        successResponse(res, {
            message: 'Successfully Find',
            data: {
                coupon,
            },
        });
    } catch (error) {
        errorResponse(res, error.message);
    }
};
exports.getAutoGeneratedCoupon = async (req, res) => {
    try {
        const couponName = await generateReferralCode();

        successResponse(res, {
            message: 'Successfully generated',
            data: {
                couponName,
            },
        });
    } catch (error) {
        errorResponse(res, error.message);
    }
};

exports.addCoupon = async (req, res) => {
    try {
        let {
            couponName,
            couponType,
            couponInfluencer,
            couponUsers,
            couponShops,
            couponShopTypes,
            couponDiscountType,
            couponValue,
            couponMinimumOrderValue,
            couponStatus,
            couponDuration,
            couponUserLimit,
            couponOrderLimit,
            couponAmountLimit,
            couponMaximumDiscountLimit,
            onlyForNewUser,
            isShopPayEnabled,
            maxNumberOfOrdersForNewUsers,
        } = req.body;

        couponName = couponName.replace(/ /g, '').toUpperCase().trim();

        if (couponName.length > 6)
            errorResponse(res, 'Coupon code length not more than 6 character');

        if (isShopPayEnabled && couponType !== 'individual_store') {
            return errorResponse(
                res,
                'isShopPayEnabled is not valid for this couponType'
            );
        }

        const checkCoupon = await CouponModel.findOne({
            couponName: couponName,
            deletedAt: null,
        });

        if (checkCoupon) {
            return errorResponse(res, 'Coupon already exist');
        }


        // if new user global coupon is already active, this condition prevents admin to add new coupon for new user
        if (checkCoupon?.couponType === 'global' && checkCoupon?.onlyForNewUser) {
            if(maxNumberOfOrdersForNewUsers < 1 || maxNumberOfOrdersForNewUsers > 5) {
                return errorResponse(res, 'Max Number of Orders must be from 1 to 5');
            }
            
            const currentDate = new Date();
            const alreadyActiveForNewUserCoupon = await CouponModel.findOne({
                couponType: 'global',
                onlyForNewUser: true,
                deletedAt: null,
                couponExpiredReason: {$exists: false}, 
                'couponDuration.end': { $gte: currentDate }, // should match with server date. currentDate is GMT +00.00
            });

            if (alreadyActiveForNewUserCoupon)
                return errorResponse(res, 'New User Coupon is already active.');
        }

        if (couponDuration) {
            couponDuration = {
                start: moment(new Date(couponDuration.start)).startOf('day'),
                end: moment(new Date(couponDuration.end)).endOf('day'),
            };
        }

        const coupon = await CouponModel.create({
            couponName,
            couponType,
            couponInfluencer,
            couponUsers,
            couponShops,
            couponShopTypes,
            couponDiscountType,
            couponValue,
            couponMinimumOrderValue,
            couponStatus,
            couponDuration,
            couponUserLimit,
            couponOrderLimit,
            couponAmountLimit,
            couponMaximumDiscountLimit,
            onlyForNewUser,
            isShopPayEnabled,
            maxNumberOfOrdersForNewUsers,
        });

        if (couponType === 'global' || couponType === 'individual_store') {
            if (!onlyForNewUser) {
                await UserModel.updateMany(
                    { deletedAt: null, status: 'active' },
                    {
                        $push: {
                            coupons: coupon._id,
                        },
                    }
                );

                await pushNotificationForCoupon(coupon);
            }
        }
        if (couponType === 'individual_user') {
            await UserModel.updateMany(
                { _id: { $in: couponUsers } },
                {
                    $push: {
                        coupons: coupon._id,
                    },
                }
            );

            await pushNotificationForCoupon(coupon);
        }

        successResponse(res, {
            message: 'Coupon added successfully',
            data: {
                coupon,
            },
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

exports.updateCoupon = async (req, res) => {
    try {
        let {
            id,
            couponName,
            // couponType,
            couponInfluencer,
            couponUsers,
            couponShops,
            couponShopTypes,
            couponDiscountType,
            couponValue,
            couponMinimumOrderValue,
            couponStatus,
            couponDuration,
            couponUserLimit,
            couponOrderLimit,
            couponAmountLimit,
            couponMaximumDiscountLimit,
            isShopPayEnabled,
            maxNumberOfOrdersForNewUsers,
        } = req.body;

        const checkCoupon = await CouponModel.findOne({
            _id: id,
            deletedAt: null,
        });

        if (!checkCoupon) {
            return errorResponse(res, 'Coupon not found');
        }

        if (checkCoupon?.couponType === 'global' && checkCoupon?.onlyForNewUser) {
            if(maxNumberOfOrdersForNewUsers < 1 || maxNumberOfOrdersForNewUsers > 5) {
                return errorResponse(res, "Max no. of orders must be from 1 to 5");
            }
        }

        if (isShopPayEnabled && checkCoupon.couponType !== 'individual_store') {
            return errorResponse(
                res,
                'isShopPayEnabled is not valid for this couponType'
            );
        }

        if (couponName) {
            couponName = couponName.replace(/ /g, '').toUpperCase().trim();

            const checkCouponCode = await CouponModel.findOne({
                _id: { $nin: [id] },
                couponName: couponName,
                deletedAt: null,
            });

            if (checkCouponCode) {
                return errorResponse(res, 'Coupon already exist');
            }
        }

        if (couponDuration) {
            couponDuration = {
                start: moment(new Date(couponDuration.start)).startOf('day'),
                end: moment(new Date(couponDuration.end)).endOf('day'),
            };
        }

        await CouponModel.findByIdAndUpdate(id, {
            couponName,
            // couponType,
            couponInfluencer,
            couponUsers,
            couponShops,
            couponShopTypes,
            couponDiscountType,
            couponValue,
            couponMinimumOrderValue,
            couponStatus,
            couponDuration,
            couponUserLimit,
            couponOrderLimit,
            couponAmountLimit,
            couponMaximumDiscountLimit,
            isShopPayEnabled,
            maxNumberOfOrdersForNewUsers,
        });

        if (couponUsers?.length) {
            await UserModel.updateMany(
                { _id: { $in: checkCoupon.couponUsers } },
                {
                    $pull: {
                        coupons: id,
                    },
                }
            );
            await UserModel.updateMany(
                { _id: { $in: couponUsers } },
                {
                    $push: {
                        coupons: id,
                    },
                }
            );
        }

        const coupon = await CouponModel.findById(id).populate(
            'couponUsers couponShops'
        );

        successResponse(res, {
            message: 'Coupon updated successfully',
            data: {
                coupon,
            },
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

exports.deleteCoupon = async (req, res) => {
    try {
        const { id } = req.body;

        const checkCoupon = await CouponModel.findOne({
            _id: id,
            deletedAt: null,
        });

        if (!checkCoupon) {
            return errorResponse(res, 'Coupon not found');
        }

        await CouponModel.findByIdAndUpdate(id, {
            deletedAt: new Date(),
        });

        successResponse(res, {
            message: 'Coupon deleted successfully',
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

exports.checkCouponForUserApp = async (req, res) => {
    try {
        const userId = req.userId;
        let { couponName, shopId, amount } = req.query;

        couponName = couponName.replace(/ /g, '').toUpperCase().trim();

        const checkCoupon = await CouponModel.findOne({
            couponName: couponName,
            deletedAt: null,
        });

        if (!checkCoupon) {
            return errorResponse(res, 'Coupon not found');
        }

        const shop = await ShopModel.findById(shopId);

        if (!shop) {
            return errorResponse(res, 'Shop not found');
        }

        const user = await UserModel.findById(userId);

        if (!user) {
            return errorResponse(res, 'User not found');
        }
        
        if (!user.coupons.includes(checkCoupon._id))    return errorResponse (res, 'You are not allowed to use this coupon');

        let sameDeviceUsersId = [user._id.toString()];

        if (user?.userRegisterDeviceId) {
            const sameDeviceUsers = await UserModel.find({
                userRegisterDeviceId: user.userRegisterDeviceId,
            });
            sameDeviceUsersId = sameDeviceUsers.map(user =>
                user._id.toString()
            );
        }

        if (checkCoupon?.couponStatus === 'inactive') {
            return errorResponse(res, 'Coupon has inactive');
        }

        // const currentDate = new Date();
        // currentDate.setHours(0, 0, 0, 0); // Get the current date
        // const currentDate = moment();

        // if (
        //     checkCoupon?.couponDuration?.start &&
        //     checkCoupon?.couponDuration?.end
        // ) {
        //     // const startDate = new Date(checkCoupon?.couponDuration?.start); // Set the start date
        //     // startDate.setHours(0, 0, 0, 0);
        //     // const endDate = new Date(checkCoupon?.couponDuration?.end);
        //     // endDate.setHours(0, 0, 0, 0);
        //     const startDate = moment(
        //         new Date(checkCoupon?.couponDuration?.start)
        //     );
        //     const endDate = moment(new Date(checkCoupon?.couponDuration?.end));

        //     if (currentDate < startDate || currentDate > endDate) {
        //         return errorResponse(res, 'Coupon has expired');
        //     }
        // }

        if (checkCoupon?.couponUserLimit > 0) {
            const userOrdersUsingThisCoupon = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                coupon: checkCoupon._id,
                user: { $in: sameDeviceUsersId },
            });

            if (checkCoupon?.couponUserLimit <= userOrdersUsingThisCoupon) {
                return errorResponse(
                    res,
                    'Coupon user order limit has been reached'
                );
            }
        }

        if (checkCoupon?.couponOrderLimit > 0) {
            const totalOrders = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                coupon: checkCoupon._id,
            });

            if (checkCoupon?.couponOrderLimit <= totalOrders) {
                return errorResponse(
                    res,
                    'Coupon order limit has been reached'
                );
            }
        }

        if (checkCoupon?.couponAmountLimit > 0) {
            const totalUsagePipeline = [
                {
                    $match: {
                        orderStatus: { $nin: ['cancelled'] },
                        // orderStatus: 'delivered',
                        coupon: checkCoupon._id,
                    },
                },
                {
                    $group: {
                        _id: null,
                        totalUsage: {
                            $sum: '$summary.baseCurrency_couponDiscountAmount',
                        },
                    },
                },
            ];

            const [totalUsageResult] = await OrderModel.aggregate(
                totalUsagePipeline
            );

            const totalUsage = totalUsageResult
                ? totalUsageResult.totalUsage
                : 0;

            if (checkCoupon?.couponAmountLimit <= totalUsage) {
                return errorResponse(
                    res,
                    'Coupon amount limit has been reached'
                );
            }
        }

        if (checkCoupon?.couponMinimumOrderValue > amount) {
            return res.status(200).json({
                status: false,
                message: 'Minimum order amount has not been met',
                error: 'Minimum order amount has not been met',
                data: {
                    couponRemainingOrderValue: parseFloat(
                        (checkCoupon.couponMinimumOrderValue - amount).toFixed(
                            2
                        )
                    ),
                    coupon: checkCoupon,
                },
            });
        }

        if (['referral_code'].includes(checkCoupon?.couponType)) {
            const totalUserOrders = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                user: { $in: sameDeviceUsersId },
            });

            if (totalUserOrders > 0) {
                return errorResponse(res, 'You are not a new user');
            }
        }

        if((checkCoupon?.couponType === 'global' &&
        checkCoupon?.onlyForNewUser)) {
            let isUserFirstRegisteredUsingThisDevice = true;
            const usersListRegisteredUsingThisDevice = await UserModel.find({
                userRegisterDeviceId: user.userRegisterDeviceId,
                phoneVerify: true,
            }).sort({
                createdAt: 1,
            });

            if (
                usersListRegisteredUsingThisDevice.length &&
                usersListRegisteredUsingThisDevice[0]._id.toString() !==
                    user._id.toString()
            ) {
                isUserFirstRegisteredUsingThisDevice = false;
            }
            if (isUserFirstRegisteredUsingThisDevice === false) return errorResponse(res, "You are not allowed to use this coupon");

            const usedCouponOrders = await OrderModel.countDocuments({
                user: userId,
                orderStatus: { $nin: ['cancelled', 'refused'] },
                /* coupon: { 
                    $ exists: true,
                }, */
                coupon: checkCoupon._id.toString(),
            });
            
            if(usedCouponOrders >= checkCoupon?.maxNumberOfOrdersForNewUsers)
                return errorResponse(res, 'You Exceeded max limit to use this coupon');
        }

        if (
            checkCoupon?.couponType === 'individual_store' &&
            checkCoupon?.onlyForNewUser
        ) {
            const totalUserOrdersOnShop = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                user: { $in: sameDeviceUsersId },
                shop: shopId,
            });
            if (totalUserOrdersOnShop > 0) {
                return errorResponse(
                    res,
                    'You have already completed an order from this shop'
                );
            }
        }

        const couponUsersList = checkCoupon?.couponUsers?.map(id =>
            id.toString()
        );
        if (
            checkCoupon?.couponUsers?.length &&
            !couponUsersList.includes(userId.toString())
        ) {
            return errorResponse(res, 'Invalid user');
        }

        const couponShopsList = checkCoupon?.couponShops?.map(id =>
            id.toString()
        );
        if (
            (checkCoupon?.couponShops?.length ||
                checkCoupon?.couponShopTypes?.length) &&
            !couponShopsList.includes(shopId.toString()) &&
            !checkCoupon?.couponShopTypes?.includes(shop.shopType)
        ) {
            return errorResponse(res, 'Invalid store');
        }

        // For restricted using self referral code
        if (
            checkCoupon?.couponType === 'referral_code' &&
            sameDeviceUsersId.includes(
                checkCoupon?.couponReferralUser?.toString()
            )
        ) {
            return errorResponse(res, 'Invalid coupon');
        }

        if (checkCoupon?.couponType === 'referral_code') {
            const referralSetting = await ReferralSettingModel.findOne({});
            const duration = referralSetting?.receiver_referralDuration || 30;

            // const startDate = new Date(user.createdAt); // Set the start date
            // startDate.setHours(0, 0, 0, 0);
            // const endDate = new Date(user.createdAt);
            // endDate.setHours(0, 0, 0, 0);
            // const updatedEndDate = new Date(
            //     endDate.setDate(endDate.getDate() + duration)
            // );
            const startDate = moment(new Date(user.createdAt));
            const endDate = moment(new Date(user.createdAt)).add(
                duration,
                'days'
            );

            if (currentDate < startDate || currentDate >= endDate) {
                return errorResponse(res, 'Coupon has expired');
            }
        }

        // For restricted using self custom coupon code
        if (
            checkCoupon?.couponType === 'custom_coupon' &&
            sameDeviceUsersId.includes(
                checkCoupon?.couponInfluencer?.toString()
            )
        ) {
            return errorResponse(res, 'Invalid coupon');
        }

        let discountAmount = 0;
        if (checkCoupon?.couponDiscountType === 'fixed') {
            discountAmount = checkCoupon?.couponValue;

        

        } else {
            discountAmount = parseFloat(
                ((checkCoupon?.couponValue * amount) / 100).toFixed(2)
            );

            if (checkCoupon?.couponMaximumDiscountLimit) {
                discountAmount =
                    discountAmount > checkCoupon.couponMaximumDiscountLimit
                        ? checkCoupon?.couponMaximumDiscountLimit
                        : discountAmount;
            }
        }

        successResponse(res, {
            message: 'Coupon calculated successfully',
            data: {
                discountAmount,
                coupon: checkCoupon,
            },
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

exports.addCouponForUserApp = async (req, res) => {
    try {
        const userId = req.userId;
        let { couponName } = req.body;

        couponName = couponName.replace(/ /g, '').toUpperCase().trim();

        const checkCoupon = await CouponModel.findOne({
            couponName: couponName,
            deletedAt: null,
        }).populate('couponUsers couponShops couponInfluencer');

        if (!checkCoupon) {
            return errorResponse(res, 'Coupon not found');
        }

        const user = await UserModel.findById(userId);
        let sameDeviceUsersId = [user._id.toString()];

        if (user?.userRegisterDeviceId) {
            const sameDeviceUsers = await UserModel.find({
                userRegisterDeviceId: user.userRegisterDeviceId,
            });
            sameDeviceUsersId = sameDeviceUsers.map(user =>
                user._id.toString()
            );
        }

        const userCouponsString = user.coupons.map(id => id.toString());
        if (userCouponsString.includes(checkCoupon._id.toString())) {
            return errorResponse(
                res,
                `Coupon is already in your list of coupons.`
            );
        }

        if (checkCoupon?.couponStatus === 'inactive') {
            return errorResponse(res, 'Coupon has inactive');
        }

        // const currentDate = new Date();
        // currentDate.setHours(0, 0, 0, 0); // Get the current date
        const currentDate = moment();

        if (
            checkCoupon?.couponDuration?.start &&
            checkCoupon?.couponDuration?.end
        ) {
            // const startDate = new Date(checkCoupon?.couponDuration?.start); // Set the start date
            // startDate.setHours(0, 0, 0, 0);
            // const endDate = new Date(checkCoupon?.couponDuration?.end);
            // endDate.setHours(0, 0, 0, 0);
            const startDate = moment(
                new Date(checkCoupon?.couponDuration?.start)
            );
            const endDate = moment(new Date(checkCoupon?.couponDuration?.end));

            if (currentDate < startDate || currentDate > endDate) {
                return errorResponse(res, 'Coupon has expired');
            }
        }

        if (checkCoupon?.couponUserLimit > 0) {
            const userOrdersUsingThisCoupon = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                coupon: checkCoupon._id,
                user: { $in: sameDeviceUsersId },
            });

            if (checkCoupon?.couponUserLimit <= userOrdersUsingThisCoupon) {
                return errorResponse(
                    res,
                    'Coupon user order limit has been reached'
                );
            }
        }

        if (checkCoupon?.couponOrderLimit > 0) {
            const totalOrders = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                coupon: checkCoupon._id,
            });

            if (checkCoupon?.couponOrderLimit <= totalOrders) {
                return errorResponse(
                    res,
                    'Coupon order limit has been reached'
                );
            }
        }

        if (checkCoupon?.couponAmountLimit > 0) {
            const totalUsagePipeline = [
                {
                    $match: {
                        orderStatus: { $nin: ['cancelled'] },
                        // orderStatus: 'delivered',
                        coupon: checkCoupon._id,
                    },
                },
                {
                    $group: {
                        _id: null,
                        totalUsage: {
                            $sum: '$summary.baseCurrency_couponDiscountAmount',
                        },
                    },
                },
            ];

            const [totalUsageResult] = await OrderModel.aggregate(
                totalUsagePipeline
            );

            const totalUsage = totalUsageResult
                ? totalUsageResult.totalUsage
                : 0;

            if (checkCoupon?.couponAmountLimit <= totalUsage) {
                return errorResponse(
                    res,
                    'Coupon amount limit has been reached'
                );
            }
        }

        if (
            ['referral_code'].includes(checkCoupon?.couponType) ||
            (checkCoupon?.couponType === 'global' &&
                checkCoupon?.onlyForNewUser)
        ) {
            const totalUserOrders = await OrderModel.countDocuments({
                orderStatus: { $nin: ['cancelled'] },
                // orderStatus: 'delivered',
                user: { $in: sameDeviceUsersId },
            });

            if (totalUserOrders > 0) {
                return errorResponse(res, 'You are not a new user');
            }
        }

        const couponUsersList = checkCoupon?.couponUsers?.map(user =>
            user._id.toString()
        );
        if (
            checkCoupon?.couponUsers?.length &&
            !couponUsersList.includes(userId.toString())
        ) {
            return errorResponse(res, 'Invalid user');
        }

        // For restricted using self referral code
        if (
            checkCoupon?.couponType === 'referral_code' &&
            sameDeviceUsersId.includes(
                checkCoupon?.couponReferralUser?.toString()
            )
        ) {
            return errorResponse(res, 'Invalid coupon');
        }

        if (checkCoupon?.couponType === 'referral_code') {
            const referralSetting = await ReferralSettingModel.findOne({});
            const duration = referralSetting?.receiver_referralDuration || 30;

            // const startDate = new Date(user.createdAt); // Set the start date
            // startDate.setHours(0, 0, 0, 0);
            // const endDate = new Date(user.createdAt);
            // endDate.setHours(0, 0, 0, 0);
            // const updatedEndDate = new Date(
            //     endDate.setDate(endDate.getDate() + duration)
            // );
            const startDate = moment(new Date(user.createdAt));
            const endDate = moment(new Date(user.createdAt)).add(
                duration,
                'days'
            );

            if (currentDate < startDate || currentDate >= endDate) {
                return errorResponse(res, 'Coupon has expired');
            }
        }

        // For restricted using self custom coupon code
        if (
            checkCoupon?.couponType === 'custom_coupon' &&
            sameDeviceUsersId.includes(
                checkCoupon?.couponInfluencer?.toString()
            )
        ) {
            return errorResponse(res, 'Invalid coupon');
        }

        await UserModel.updateOne(
            { _id: userId },
            {
                $push: {
                    coupons: checkCoupon._id,
                },
            }
        );

        successResponse(res, {
            message: 'Coupon added successfully',
            data: {
                coupon: checkCoupon,
            },
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

exports.couponHistoryForUserApp = async (req, res) => {
    try {

     
        const userId = req.userId;
        const {
            page = 1,
            pageSize = 50,
            type = 'valid', //valid, used, expired
        } = req.query;

        const { usedCouponOrders, validCoupons, expiredCoupons }
            =  await getCouponHistory(userId);
          

        let couponHistory = [];
        let paginate = {};

        if (type === 'used') {
            paginate = await paginationMultipleModel({
                page,
                pageSize,
                total: usedCouponOrders.length,
                pagingRange: 5,
            });
            couponHistory = usedCouponOrders.slice(
                paginate.offset,
                paginate.offset + paginate.limit
            );
        } else if (type === 'valid') {
            paginate = await paginationMultipleModel({
                page,
                pageSize,
                total: validCoupons?.length,
                pagingRange: 5,
            });
            const list = validCoupons?.reverse();
            couponHistory = list.slice(
                paginate.offset,
                paginate.offset + paginate.limit
            );
        } else if (type === 'expired') {
            paginate = await paginationMultipleModel({
                page,
                pageSize,
                total: expiredCoupons?.length,
                pagingRange: 5,
            });
            const list = expiredCoupons?.sort(
                (a, b) =>
                    new Date(b.couponDuration.end) -
                    new Date(a.couponDuration.end)
            );
            couponHistory = list.slice(
                paginate.offset,
                paginate.offset + paginate.limit
            );
        }

        successResponse(res, {
            message: 'Find successfully',
            data: {
                couponHistory,
                paginate,
            },
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

exports.getCouponsOverview = async (req, res) => {
    try {
        const { startDate, endDate } = req.query;

        let config = {
            deletedAt: null,
            couponStatus: 'active',
            couponType: { $nin: ['referral_code'] },
        };

        if (startDate && endDate) {
            const startDateTime = moment(new Date(startDate))
                .startOf('day')
                .toDate();
            const endDateTime = moment(endDate ? new Date(endDate) : new Date())
                .endOf('day')
                .toDate();

            config = {
                ...config,
                createdAt: {
                    $gte: startDateTime,
                    $lte: endDateTime,
                },
            };
        }

        const list = await CouponModel.find(config);

        const validCoupons = [];
        const expiredCoupons = [];

        for (const coupon of list) {
            const isValidCoupons = await checkCouponValidity(coupon);
            if (isValidCoupons) {
                validCoupons.push(coupon);
            } else {
                expiredCoupons.push(coupon);
            }
        }

        const couponsOverview = calcCouponOverview(list, validCoupons);

        const totalGlobalCoupons = list.filter(
            coupon => coupon.couponType === 'global'
        );
        const globalCoupons = validCoupons.filter(
            coupon => coupon.couponType === 'global'
        );
        const globalCouponsInfo = calcCouponOverview(
            totalGlobalCoupons,
            globalCoupons
        );

        const totalIndividualStoreCoupons = list.filter(
            coupon => coupon.couponType === 'individual_store'
        );
        const individualStoreCoupons = validCoupons.filter(
            coupon => coupon.couponType === 'individual_store'
        );
        const individualStoreCouponsInfo = calcCouponOverview(
            totalIndividualStoreCoupons,
            individualStoreCoupons
        );

        const totalIndividualUserCoupons = list.filter(
            coupon => coupon.couponType === 'individual_user'
        );
        const individualUserCoupons = validCoupons.filter(
            coupon => coupon.couponType === 'individual_user'
        );
        const individualUserCouponsInfo = calcCouponOverview(
            totalIndividualUserCoupons,
            individualUserCoupons
        );

        const totalCustomCoupons = list.filter(
            coupon => coupon.couponType === 'custom_coupon'
        );
        const customCoupons = validCoupons.filter(
            coupon => coupon.couponType === 'custom_coupon'
        );
        const customCouponsInfo = calcCouponOverview(
            totalCustomCoupons,
            customCoupons
        );

        // Calc order increase percentage
        const timeDiff =
            new Date(endDate).getTime() - new Date(startDate).getTime();
        const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

        const oldEndDate = new Date(startDate);
        oldEndDate.setDate(oldEndDate.getDate() - 1);
        const oldStartDate = new Date(oldEndDate);
        oldStartDate.setDate(oldStartDate.getDate() - daysDiff);

        let orderConfig = {
            coupon: { $exists: true },
            orderStatus: 'delivered',
        };

        const orderList = await OrderModel.find(orderConfig).populate('coupon');
        const orders = orderList.filter(
            order => order.coupon.couponType !== 'referral_code'
        );
        const totalOrders = orders.length;

        const ordersOnPromotionList = await OrderModel.find({
            ...orderConfig,
            createdAt: {
                $gte: moment(new Date(startDate)),
                $lt: moment(new Date(endDate)).add(1, 'days'),
            },
        }).populate('coupon');
        const ordersOnPromotion = ordersOnPromotionList.filter(
            order => order.coupon.couponType !== 'referral_code'
        );
        const globalOrdersOnPromotion = ordersOnPromotion.filter(
            order => order.coupon.couponType === 'global'
        );
        const individualStoreOrdersOnPromotion = ordersOnPromotion.filter(
            order => order.coupon.couponType === 'individual_store'
        );
        const individualUserOrdersOnPromotion = ordersOnPromotion.filter(
            order => order.coupon.couponType === 'individual_user'
        );
        const customOrdersOnPromotion = ordersOnPromotion.filter(
            order => order.coupon.couponType === 'custom_coupon'
        );

        const totalOrdersOnPromotion = ordersOnPromotion.length;
        const totalGlobalOrdersOnPromotion = globalOrdersOnPromotion.length;
        const totalIndividualStoreOrdersOnPromotion =
            individualStoreOrdersOnPromotion.length;
        const totalIndividualUserOrdersOnPromotion =
            individualUserOrdersOnPromotion.length;
        const totalCustomOrdersOnPromotion = customOrdersOnPromotion.length;

        const ordersLastDaysList = await OrderModel.find({
            ...orderConfig,
            createdAt: {
                $gte: moment(new Date(oldStartDate)),
                $lt: moment(new Date(oldEndDate)).add(1, 'days'),
            },
        }).populate('coupon');
        const ordersLastDays = ordersLastDaysList.filter(
            order => order.coupon.couponType !== 'referral_code'
        );
        const globalOrdersLastDays = ordersLastDays.filter(
            order => order.coupon.couponType === 'global'
        );
        const individualStoreOrdersLastDays = ordersLastDays.filter(
            order => order.coupon.couponType === 'individual_store'
        );
        const individualUserOrdersLastDays = ordersLastDays.filter(
            order => order.coupon.couponType === 'individual_user'
        );
        const customOrdersLastDays = ordersLastDays.filter(
            order => order.coupon.couponType === 'custom_coupon'
        );

        const totalOrdersLastDays = ordersLastDays.length;
        const totalGlobalOrdersLastDays = globalOrdersLastDays.length;
        const totalIndividualStoreOrdersLastDays =
            individualStoreOrdersLastDays.length;
        const totalIndividualUserOrdersLastDays =
            individualUserOrdersLastDays.length;
        const totalCustomOrdersLastDays = customOrdersLastDays.length;

        const orderPercentage = (totalOrdersOnPromotion / totalOrders) * 100;
        const globalOrderPercentage =
            (totalGlobalOrdersOnPromotion / totalOrders) * 100;
        const individualStoreOrderPercentage =
            (totalIndividualStoreOrdersOnPromotion / totalOrders) * 100;
        const individualUserOrderPercentage =
            (totalIndividualUserOrdersOnPromotion / totalOrders) * 100;
        const customOrderPercentage =
            (totalCustomOrdersOnPromotion / totalOrders) * 100;

        const orderPercentageLastDays =
            (totalOrdersLastDays / totalOrders) * 100;
        const globalOrderPercentageLastDays =
            (totalGlobalOrdersLastDays / totalOrders) * 100;
        const individualStoreOrderPercentageLastDays =
            (totalIndividualStoreOrdersLastDays / totalOrders) * 100;
        const individualUserOrderPercentageLastDays =
            (totalIndividualUserOrdersLastDays / totalOrders) * 100;
        const customOrderPercentageLastDays =
            (totalCustomOrdersLastDays / totalOrders) * 100;

        const orderIncreasePercentage = parseFloat(
            (orderPercentage - orderPercentageLastDays).toFixed(2)
        );
        const globalOrderIncreasePercentage = parseFloat(
            (globalOrderPercentage - globalOrderPercentageLastDays).toFixed(2)
        );
        const individualStoreOrderIncreasePercentage = parseFloat(
            (
                individualStoreOrderPercentage -
                individualStoreOrderPercentageLastDays
            ).toFixed(2)
        );
        const individualUserOrderIncreasePercentage = parseFloat(
            (
                individualUserOrderPercentage -
                individualUserOrderPercentageLastDays
            ).toFixed(2)
        );
        const customOrderIncreasePercentage = parseFloat(
            (customOrderPercentage - customOrderPercentageLastDays).toFixed(2)
        );

        successResponse(res, {
            message: 'Successfully Find',
            data: {
                couponsOverview: {
                    ...couponsOverview,
                    orderIncreasePercentage: orderIncreasePercentage,
                },
                globalCouponsInfo: {
                    ...globalCouponsInfo,
                    orderIncreasePercentage: globalOrderIncreasePercentage,
                },
                individualStoreCouponsInfo: {
                    ...individualStoreCouponsInfo,
                    orderIncreasePercentage:
                        individualStoreOrderIncreasePercentage,
                },
                individualUserCouponsInfo: {
                    ...individualUserCouponsInfo,
                    orderIncreasePercentage:
                        individualUserOrderIncreasePercentage,
                },
                customCouponsInfo: {
                    ...customCouponsInfo,
                    orderIncreasePercentage: customOrderIncreasePercentage,
                },
            },
        });
    } catch (error) {
        errorResponse(res, error.message);
    }
};

exports.userValidCouponForShop = async (req, res) => {
    try {
        const userId = req.userId;
        const { page = 1, pageSize = 50, shopId } = req.query;

        const shop = await ShopModel.findById(shopId);

        if (!shop) {
            return errorResponse(res, 'Shop not found');
        }

        const user = await UserModel.findById(userId).populate([
            {
                path: 'coupons',
                // populate: [
                //     {
                //         path: 'couponInfluencer',
                //     },
                //     {
                //         path: 'couponReferralUser',
                //     },
                //     {
                //         path: 'couponUsers',
                //     },
                //     {
                //         path: 'couponShops',
                //     },
                // ],
            },
        ]);
        const validCoupons = [];

        let sameDeviceUsersId = [user._id.toString()];

        if (user?.userRegisterDeviceId) {
            const sameDeviceUsers = await UserModel.find({
                userRegisterDeviceId: user.userRegisterDeviceId,
            });
            sameDeviceUsersId = sameDeviceUsers.map(user =>
                user._id.toString()
            );
        }

        for (const coupon of user?.coupons || []) {
            let checkCoupon = true;
            if (checkCoupon && coupon?.deletedAt) {
                checkCoupon = false;
            }

            if (checkCoupon && coupon?.couponStatus === 'inactive') {
                checkCoupon = false;
            }

            // const currentDate = new Date();
            // currentDate.setHours(0, 0, 0, 0); // Get the current date
            const currentDate = moment();

            if (
                checkCoupon &&
                coupon?.couponDuration?.start &&
                coupon?.couponDuration?.end
            ) {
                // const startDate = new Date(coupon?.couponDuration?.start); // Set the start date
                // startDate.setHours(0, 0, 0, 0);
                // const endDate = new Date(coupon?.couponDuration?.end);
                // endDate.setHours(0, 0, 0, 0);
                const startDate = moment(
                    new Date(coupon?.couponDuration?.start)
                );
                const endDate = moment(new Date(coupon?.couponDuration?.end));

                if (currentDate < startDate || currentDate > endDate) {
                    checkCoupon = false;
                }
            }

            if (checkCoupon && coupon?.couponUserLimit > 0) {
                const userOrdersUsingThisCoupon =
                    await OrderModel.countDocuments({
                        orderStatus: { $nin: ['cancelled'] },
                        // orderStatus: 'delivered',
                        coupon: coupon._id,
                        user: { $in: sameDeviceUsersId },
                    });
                if (coupon?.couponUserLimit <= userOrdersUsingThisCoupon) {
                    checkCoupon = false;
                }
            }
            if (checkCoupon && coupon?.couponOrderLimit > 0) {
                const totalOrders = await OrderModel.countDocuments({
                    orderStatus: { $nin: ['cancelled'] },
                    // orderStatus: 'delivered',
                    coupon: coupon._id,
                });

                if (coupon?.couponOrderLimit <= totalOrders) {
                    checkCoupon = false;
                }
            }
            if (checkCoupon && coupon?.couponAmountLimit > 0) {
                const totalUsagePipeline = [
                    {
                        $match: {
                            orderStatus: { $nin: ['cancelled'] },
                            // orderStatus: 'delivered',
                            coupon: coupon._id,
                        },
                    },
                    {
                        $group: {
                            _id: null,
                            totalUsage: {
                                $sum: '$summary.baseCurrency_couponDiscountAmount',
                            },
                        },
                    },
                ];

                const [totalUsageResult] = await OrderModel.aggregate(
                    totalUsagePipeline
                );

                const totalUsage = totalUsageResult
                    ? totalUsageResult.totalUsage
                    : 0;

                if (coupon?.couponAmountLimit <= totalUsage) {
                    checkCoupon = false;
                }
            }
            if (
                checkCoupon &&
                (['referral_code'].includes(coupon?.couponType) ||
                    (coupon?.couponType === 'global' && coupon?.onlyForNewUser))
            ) {
                const totalUserOrders = await OrderModel.countDocuments({
                    orderStatus: { $nin: ['cancelled'] },
                    // orderStatus: 'delivered',
                    user: { $in: sameDeviceUsersId },
                });
                if (totalUserOrders > 0) {
                    checkCoupon = false;
                }
            }
            if (
                checkCoupon &&
                coupon?.couponType === 'individual_store' &&
                coupon?.onlyForNewUser
            ) {
                const totalUserOrdersOnShop = await OrderModel.countDocuments({
                    orderStatus: { $nin: ['cancelled'] },
                    // orderStatus: 'delivered',
                    user: { $in: sameDeviceUsersId },
                    shop: shopId,
                });
                if (totalUserOrdersOnShop > 0) {
                    checkCoupon = false;
                }
            }

            const couponUsersList = coupon?.couponUsers?.map(userId =>
                userId.toString()
            );
            if (
                checkCoupon &&
                coupon?.couponUsers?.length &&
                !couponUsersList.includes(userId.toString())
            ) {
                checkCoupon = false;
            }

            const couponShopsList = coupon?.couponShops?.map(shopId =>
                shopId.toString()
            );
            if (
                checkCoupon &&
                (coupon?.couponShops?.length ||
                    coupon?.couponShopTypes?.length) &&
                !couponShopsList.includes(shopId.toString()) &&
                !coupon?.couponShopTypes?.includes(shop.shopType)
            ) {
                checkCoupon = false;
            }

            if (checkCoupon && ['referral_code'].includes(coupon?.couponType)) {
                const referralSetting = await ReferralSettingModel.findOne({});
                const duration =
                    referralSetting?.receiver_referralDuration || 30;

                // const startDate = new Date(user.createdAt); // Set the start date
                // startDate.setHours(0, 0, 0, 0);
                // const endDate = new Date(user.createdAt);
                // endDate.setHours(0, 0, 0, 0);
                // const updatedEndDate = new Date(
                //     endDate.setDate(endDate.getDate() + duration)
                // );
                const startDate = moment(new Date(user.createdAt));
                const endDate = moment(new Date(user.createdAt)).add(
                    duration,
                    'days'
                );

                if (currentDate < startDate || currentDate >= endDate) {
                    checkCoupon = false;
                }
            }

            let isUserFirstRegisteredUsingThisDevice = true;

            const usersListRegisteredUsingThisDevice = await UserModel.find({
                userRegisterDeviceId: user.userRegisterDeviceId,
                phoneVerify: true,
            }).sort({  createdAt: 1, });
            
            if (usersListRegisteredUsingThisDevice.length && 
                usersListRegisteredUsingThisDevice[0]._id.toString() !== user._id.toString()) {
                    isUserFirstRegisteredUsingThisDevice = false;
                }

            if (isUserFirstRegisteredUsingThisDevice === false)    checkCoupon = false;
            
            
            if (checkCoupon) {
                validCoupons.push(coupon);
            }
        }

        let paginate = await paginationMultipleModel({
            page,
            pageSize,
            total: validCoupons?.length,
            pagingRange: 5,
        });

        const list = validCoupons?.reverse();
        let couponHistory = list.slice(
            paginate.offset,
            paginate.offset + paginate.limit
        );

        successResponse(res, {
            message: 'Find successfully',
            data: {
                coupons: couponHistory,
                paginate,
            },
        });
    } catch (error) {
        errorHandler(res, error);
    }
};

const calcCouponOverview = (list, coupons) => {
    let totalCouponsAmountSpent = 0;
    const totalValidCoupons = coupons.length;
    const totalCoupons = list.length;
    let totalCouponsOrders = 0;
    let totalCouponsUsageOrders = 0;

    for (const element of coupons) {
        const coupon = { ...element._doc };
        totalCouponsAmountSpent += coupon.couponTotalUsageAmount;
        totalCouponsOrders += coupon.couponOrderLimit;
        totalCouponsUsageOrders += coupon.couponTotalUsageOrders;
    }
    const totalCouponsUsagePercentage =
        parseFloat(
            ((totalCouponsUsageOrders * 100) / totalCouponsOrders).toFixed(2)
        ) || 0;

    return {
        totalCouponsAmountSpent,
        totalValidCoupons,
        totalCoupons,
        totalCouponsOrders,
        totalCouponsUsageOrders,
        totalCouponsUsagePercentage:
            totalCouponsUsagePercentage === Infinity
                ? 100
                : totalCouponsUsagePercentage,
    };
};
